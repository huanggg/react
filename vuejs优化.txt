
vue 打包文件加版本号防止缓存文件不更新

  解决方法：找到webpack .prod.conf.js


  1.定义版本变量： const Version = new Date().getTime(); // 这里使用的是时间戳 来区分 ，也可以自己定义成别的如：1.1
  2.修改要生成的js和css文件的配置项，把刚刚声明的版本拼接进要生成的文件名中
 output:{

     path: config.build.assetsRoot,
     filename: utils.assetsPath('js/[name].[chunkhash].' + Version + '.js'),
     chunkFilename: utils.assetsPath('js/[id].[chunkhash].' + Version + '.js')
   },


    new ExtractTextPlugin({

         filename: utils.assetsPath('css/[name].[contenthash]'+Version+'.css'),

         allChunks: true

   })



  vue——项目优化，缩短首屏加载时间

 1 代码包优化

  1-1 屏蔽sourceMap 
    config目录 index下 在build对象中的配置信息中，productionSourceMap修改成false:
    压缩代码并移除console
    webpack.prod.conf.js下
    new UglifyJsPlugin({
      uglifyOptions: {
        compress: {
          warnings: false,
          drop_debugger: true,
          drop_console: true
        }
      },

   

  1-2 对路由组件进行懒加载 

    component: resolve=>require(["@/views/home"],resolve)

  1-3 对项目代码中的JS/CSS/SVG(*.ico)文件进行gzip压缩

2 源码优化

  2-1 v-if he v-show  的选择调用
      v-show和v-if的区别是：v-if是懒加载，当状态为true时才会加载，并且为false时不
      会占用布局空间；v-show是无论状态是true或者是false，都会进行渲染，并对布局
      占据空间对于在项目中，需要频繁调用，不需要权限的显示隐藏，可以选择使用v-
      show，可以减少系统的切换开销。
  2-2 为item设置唯一key值，
      在列表渲染时，为每一项item设置唯一的key值，方便
      vuejs 内部机制精准找到该条列表数据。当state更新时，
      新的状态值和旧的状态值对比，较快地定位到diff。
     
  2-3 细分vuejs组件
      在项目开发过程之中，第一版本把所有的组件的布局写在一个组件中，当数据变更
      时，由于组件代码比较庞大，vuejs的数据驱动视图更新比较慢，造成渲染比较
      慢。造成比较差的体验效果。所以把组件细分，比如一个组件，可以把整个组件细
      分成轮播组件、列表组件、分页组件等。

  2-4 减少watch的数据
      当组件某个数据变更后需要对应的state进行变更，就需要对另外的组件进行state
      进行变更。可以使用watch监听相应的数据变更并绑定事件。当watch的数据比较
      小，性能消耗不明显。当数据变大，系统会出现卡顿，所以减少watch的数据。其
      它不同的组件的state双向绑定，可以采用事件中央总线或者vuex进行数据的变更操作。

  2-5 内容类系统的图片资源按需加载

      对于内容类系统的图片按需加载，如果出现图片加载比较多，可以先使用v-lazy之
      类的懒加载库或者绑定鼠标的scroll事件，滚动到可视区域先再对数据进行加载显
      示，减少系统加载的数据

3.用户体验优化

4 其它优化

  4-1 菊花loading

  4-2 浏览器缓存机制。

  4-3 element-ui 按需加载组件

  4-4 使用cdn 
   网络方面
     减少http请求
        合并js文件

        合并css文件

        雪碧图的使用(css sprite)

        使用base64表示简单的图片
    减小资源体积：

        gzip压缩

        js混淆

        css压缩

        图片压缩
    缓存
        DNS缓存

        CDN部署与缓存

        http缓存
       
        尽量避免dom操作
        
        1 将10W条数据一次渲染到页面上怎么防止ui渲染卡顿？？？

                            分析：
                            ·数据量过大，出现卡顿感的主要原因是，在每次循环中，都会修改 DOM 结构（导致页面dom树重绘,回流），并且由于数据量大，导致循环执行时间过长（导致页面卡顿），浏览器的渲                              染帧率过低（导致闪屏现象)。
                            ·从 减少 DOM 操作次数 和 缩短循环时间 两个方面减少主线程阻塞的时间.
                            ·通过 DocumentFragment 的使用，减少 DOM 操作次数，降低回流对性能的影响;
                            （DocumentFragment是DOM的节点，但并不是DOM树的一部分，存在内存中。当append元素到document中时，会同时计算样式表，而append元素到documentFragment时，不会计算元素                              的样式表，所以documentFragment性能更优。）
                            ·在缩短循环时间方面，我们可以通过 分治 的思想，将 100000 个 li 分批插入到页面中，并且我们通过 requestAnimatiomnFrame 在页面重绘前插入新节点。
                            （requestAnimatiomnFrame的步伐跟着系统刷新的步伐走。能保证回调函数在屏幕每一次的刷新间隔只被执行一次，这样就不会引起丢帧现象。）

                            DocumentFragment节点不属于文档树，继承的parentNode属性总是null。它有一个很实用的特点，当请求把一个DocumentFragment节点插入文档树时，插入的不是                                           DocumentFragment自身，而是它的所有子孙节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点

                           代码实现：

                           function loop() {              
                                window.requestAnimationFrame(()=>{
                                    let fragment = document.createDocumentFragment()//创建DocumentFragment节点
                                    for (let i = 0; i < 100000; i++) {
                                        let li = document.createElement('li');
                                        li.innerText = 'test'
                                        fragment.appendChild(li);
                                    }
                                  document.body.appendChild(fragment);//然后用appendChild插入文档中             
                                })
                            }
                            loop()

vue单页面通过prerender-spa-plugin插件进行SEO优化

Vue打包文件放在服务器，浏览器存在缓存问题的解决

  解决方法：找到webpack .prod.conf.js

   1.定义版本变量： const  Version = new Date().getTime(); // 这里使用的是时间戳 来区分 ，也可以自己定义成别的如：1.1

   2.修改要生成的js和css文件的配置项，把刚刚声明的版本拼接进要生成的文件名中；

   output: {

        path: config.build.assetsRoot,

         filename: utils.assetsPath('js/[name].[chunkhash].' + Version + '.js'),

        chunkFilename: utils.assetsPath('js/[id].[chunkhash].' + Version + '.js')

    },

  然后直接 npm run build 打包后 就可以看到dist 文件里的js 文件名带上里版本号

3 js 数据结构与算法
   
4 js 设计模式
  
5 vuex 状态管理
 
6 router 路由

7 vue响应式原理
 
8 vuejs 的生命周期

9 mvvm 的理解
  
10 vue父子组件的数据传递
 
11 git 的常用命令
  
12 Vue中观察者模式介绍

13 递归

14 webpack 配置vuejs项目


15 前端的基础知识

16 http 工作原理
   概念：http：是一种基于tcp/ip 的超文本传输协议

17 闭包的优点与缺点
   闭包是能够访问另一个函数作用域中变量的函数(这个“另外一个函数”，通常指的是包含闭包函数的外部函数)
  1 优点
    1 加强代码封装性，用于设计私有的方法与变量（例如jquery）
    2 为变量存储内存提供途径（在内存中维持了一个变量）
  2 缺点
    1 过多的使用闭包，可能导致内存泄露
18 事件代理的优缺点
  1 优点
    1 减少了dom 的操作，节省内存（在ul 上代理所有li的click事件）
    2 实现为新增元素自动添加或移除事件 (不用为新添加的li绑定click事件)
  2 缺点
    1 事件代理基于冒泡，对于不冒泡的事件不支持
    2 层级过多，冒泡过程中，可能会被某层阻止掉
 
   
 
