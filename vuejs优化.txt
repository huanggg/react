vue 打包文件加版本号防止缓存文件不更新
  解决方法：找到webpack .prod.conf.js
  1.定义版本变量： const Version = new Date().getTime(); // 这里使用的是时间戳 来区分 ，也可以自己定义成别的如：1.1
  2.修改要生成的js和css文件的配置项，把刚刚声明的版本拼接进要生成的文件名中
 output:{
     path: config.build.assetsRoot,
     filename: utils.assetsPath('js/[name].[chunkhash].' + Version + '.js'),
     chunkFilename: utils.assetsPath('js/[id].[chunkhash].' + Version + '.js')
   },
    new ExtractTextPlugin({
         filename: utils.assetsPath('css/[name].[contenthash]'+Version+'.css'),
         allChunks: true
   })
  vue——项目优化，缩短首屏加载时间

       1 代码包优化
          1-1 屏蔽sourceMap 
            config目录 index下 在build对象中的配置信息中，productionSourceMap修改成false:
            压缩代码并移除console
            webpack.prod.conf.js下
            new UglifyJsPlugin({
              uglifyOptions: {
                compress: {
                  warnings: false,
                  drop_debugger: true,
                  drop_console: true
                }
              },
      1-2 对路由组件进行懒加载 
           component: resolve=>require(["@/views/home"],resolve)
      1-3 对项目代码中的JS/CSS/SVG(*.ico)文件进行gzip压缩
    2 源码优化
      2-1 v-if he v-show  的选择调用
          v-show和v-if的区别是：v-if是懒加载，当状态为true时才会加载，并且为false时不
          会占用布局空间；v-show是无论状态是true或者是false，都会进行渲染，并对布局
          占据空间对于在项目中，需要频繁调用，不需要权限的显示隐藏，可以选择使用v-
          show，可以减少系统的切换开销。
      2-2 为item设置唯一key值，
          在列表渲染时，为每一项item设置唯一的key值，方便
          vuejs 内部机制精准找到该条列表数据。当state更新时，
          新的状态值和旧的状态值对比，较快地定位到diff。
      2-3 细分vuejs组件
          在项目开发过程之中，第一版本把所有的组件的布局写在一个组件中，当数据变更
          时，由于组件代码比较庞大，vuejs的数据驱动视图更新比较慢，造成渲染比较
          慢。造成比较差的体验效果。所以把组件细分，比如一个组件，可以把整个组件细
          分成轮播组件、列表组件、分页组件等。
      2-4 减少watch的数据
          当组件某个数据变更后需要对应的state进行变更，就需要对另外的组件进行state
          进行变更。可以使用watch监听相应的数据变更并绑定事件。当watch的数据比较
          小，性能消耗不明显。当数据变大，系统会出现卡顿，所以减少watch的数据。其
          它不同的组件的state双向绑定，可以采用事件中央总线或者vuex进行数据的变更操作。
      2-5 内容类系统的图片资源按需加载
          对于内容类系统的图片按需加载，如果出现图片加载比较多，可以先使用v-lazy之
          类的懒加载库或者绑定鼠标的scroll事件，滚动到可视区域先再对数据进行加载显
          示，减少系统加载的数据
4 其它优化
  4-1 菊花loading
  4-2 浏览器缓存机制。
  4-3 element-ui 按需加载组件
  4-4 使用cdn 
   网络方面
     减少http请求
        合并js文件
        合并css文件
        雪碧图的使用(css sprite)
        使用base64表示简单的图片
    减小资源体积：
        gzip压缩
        js混淆
        css压缩
        图片压缩
    缓存
        DNS缓存
        CDN部署与缓存
        http缓存
        尽量避免dom操作
        1 将10W条数据一次渲染到页面上怎么防止ui渲染卡顿？？？
                            分析：
                            ·数据量过大，出现卡顿感的主要原因是，在每次循环中，都会修改 DOM 结构（导致页面dom树重绘,回流），并且由于数据量大，导致循环执行时间过长（导致页面卡顿），浏览器的渲                              染帧率过低（导致闪屏现象)。
                            ·从 减少 DOM 操作次数 和 缩短循环时间 两个方面减少主线程阻塞的时间.
                            ·通过 DocumentFragment 的使用，减少 DOM 操作次数，降低回流对性能的影响;
                            （DocumentFragment是DOM的节点，但并不是DOM树的一部分，存在内存中。当append元素到document中时，会同时计算样式表，而append元素到documentFragment时，不会计算元素                              的样式表，所以documentFragment性能更优。）
                            ·在缩短循环时间方面，我们可以通过 分治 的思想，将 100000 个 li 分批插入到页面中，并且我们通过 requestAnimatiomnFrame 在页面重绘前插入新节点。
                            （requestAnimatiomnFrame的步伐跟着系统刷新的步伐走。能保证回调函数在屏幕每一次的刷新间隔只被执行一次，这样就不会引起丢帧现象。）
                            DocumentFragment节点不属于文档树，继承的parentNode属性总是null。它有一个很实用的特点，当请求把一个DocumentFragment节点插入文档树时，插入的不是                                           DocumentFragment自身，而是它的所有子孙节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点
                           代码实现：
                           function loop() {              
                                window.requestAnimationFrame(()=>{
                                    let fragment = document.createDocumentFragment()//创建DocumentFragment节点
                                    for (let i = 0; i < 100000; i++) {
                                        let li = document.createElement('li');
                                        li.innerText = 'test'
                                        fragment.appendChild(li);
                                    }
                                  document.body.appendChild(fragment);//然后用appendChild插入文档中             
                                })
                            }
                            loop()

vue单页面通过prerender-spa-plugin插件进行SEO优化


 
   
 
