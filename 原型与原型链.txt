1 网络七层协议

 应用层
 表示层
 回话层
 传输层
 网络层
 数据链路层
 物理层

我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，一个对象。
无论什么时候，我们只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，
这个属性对象指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constroctor（构造函数）属性，
这个属性包含一个指向prototype属性所在函数的指针。


把这个有__proto__串起来的直到Object.prototype.__proto__为null的链叫做原型链。原型链实际上就是js中数据继承的继承链。

 
1.原型：


每个函数都会默认有一个prototype属性，它是一个指针，指向此函数的原型对象。而构造函数作为一个函数
同样拥有自己的原型对象，而通过构造函数生成的对象实例中，拥有一个_proto_ 属性，它指向构造函数的原型对象，
我们把构造函数的原型对象称为对象实例的原型。


如图：person就是构造函数，而Person prototype原型对象，也是对象实例person1的原型，
此实例会继承所有存在它原型中的所有属性及方法。





原型链


既然每个实例对象都有一个原型，而每个构造函数也都能创建实例，
那假如我们将构造函数 f1 的原型属性指向构造函数f2的实例对象，那么构造函数f1的实例对象就能访问f2的原型属性，依次类推，
我们还可以把构造函数f3的原型属性指向f2的队实例对象，那么f3的实例对象同样可以访问到f1的原型，这样，就构成了一条原型链。


如图：从上到下依次讲解，首先，原型链的顶端是Object prototype ,它的_proto_ 属性为 ,接下来看构造函数SuperType ,
它的prototype属性指向的是原型对象SuperType prototype ,这个原型对象其实是Object的一个实例对象，
因为它的_proto_ 属性指向Object prototype ,因此，SuperType 的实例属性可以访问Object prototype 中的属性与方法。


同理，我们通过SubType.prototype=new SuperType(),可以将subType的原型对象指向为SuperType的一个实例对象，
这样SubType 的实例对象instance通过原型链可以访问到上面三个原型中的合法属性与方法。


--------------------- 
